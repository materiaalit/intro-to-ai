<!DOCTYPE html>
<html>
  <head>
    <title>Introduction to Artificial Intelligence 2018 | Part 2</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

    <link href="../stylesheets/styles-b17821ab.css" rel="stylesheet" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/xcode.min.css">

    <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.css" />

      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-47575342-7', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');
</script>

  </head>
  <body>
    <div class="main-wrapper">
      <div class="header-wrapper">
        <div class="browser-support-warning" id="browser-support-warning" style="display: none;">
  Kaikki tämän materiaalin osat eivät välttämättä tuo nykyistä selaintasi. Voisitko harkita vaihtamista <a href="https://www.google.com/chrome/browser/desktop/" target="_blank" rel="noopener">Chrome</a> tai <a href="https://www.mozilla.org/en-US/firefox/new/" target="_blank" rel="noopener">Firefox</a> selaimeen?
  <span class="browser-support-warning__close">Selvä!</span>
</div>


        <nav class="navbar navbar-light bg-white">
  <a class="navbar-brand" href="http://mooc.fi" alt="MOOC" target="_blank" rel="noopener">
    <span class="icon-mooc"></span>
  </a>

  <ul class="nav navbar-nav hidden-md-down">
      <li class="nav-item ">
        <a href="../" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=index.html&gt;')">Introduction</a>
      </li>
      <li class="nav-item ">
        <a href="../part1/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part1.html&gt;')">Part 1</a>
      </li>
      <li class="nav-item active">
        <a href="./" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part2.html&gt;')">Part 2</a>
      </li>
      <li class="nav-item ">
        <a href="../part3/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part3.html&gt;')">Part 3</a>
      </li>
      <li class="nav-item ">
        <a href="../part4/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part4.html&gt;')">Part 4</a>
      </li>
      <li class="nav-item ">
        <a href="../part5/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part5.html&gt;')">Part 5</a>
      </li>
      <li class="nav-item ">
        <a href="../part6/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part6.html&gt;')">Part 6</a>
      </li>
  </ul>

  <div class="float-xs-right navbar__buttons">
    <div class="dropdown" id="mobile-nav-dropdown">
      <button class="btn btn-secondary dropdown-toggle navbar__mobile-nav-toggle" data-toggle="dropdown">
        <i class="fa fa-bars"></i>
      </button>

      <div class="dropdown-menu">
      </div>
    </div>

    <a href="https://piazza.com/class/jlpi39tn8c0i" target="_blank" rel="noopener" class="btn btn-secondary">
      <span class="hidden-md-down">Discussion forum</span>
      <i class="fa fa-commenting-o hidden-lg-up"></i>
    </a>

    <button class="btn btn-secondary" id="table-of-contents-toggle">
      <span class="hidden-md-down">Table of contents</span>
      <i class="fa fa-ellipsis-h hidden-lg-up"></i>
    </button>

    <button class="btn btn-primary" id="tmc-login-toggle">Log in</button>
  </div>
</nav>

      </div>

      <div class="content-wrapper">
        <div class="container material" id="material">
            <div class="exercise-list">
  <div class="exercise-list__header">
    Exercises
  </div>

  <div class="exercise-list__content" id="exercise-list"></div>

</div>


          
<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">TravelPlanner v2.0 (AStar) (2p)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
<p>
  This week's first exercise is a continuation of the TravelPlanner
  from last week. The only difference is the change of algorithm:
  instead of breadth-first search, you should now implement A*
  search.
</p>

<p>
  The cost associated with each transition from one stop to the next
  is the time required for the transition. This includes both the time
  spent waiting for the tram and the actual travel time. In our imaginary
  scenario, all trams leave at regular 10 minute intervals from their
  first stop (each line is given both ways, so another tram will leave
  at the same time from the other end).
</p>

<p>
  Your route query will be given in the form:
<pre>
      TravelPlanner.search(departureStop, destinationStop, departureTime)
</pre>
  where the departure time can be given in minutes since the last full
  10 minutes since the timetable of our tram network is so regular.
</p>

<p>
  You'll need to complete the following steps (these instructions apply
  directly to Java but the general idea is the same in other
  languages):
  <ol>
    <li> Implement a <code>StateComparator</code> class (the Java package
      already has a template for this) with
      method <code>heuristic(Stop s)</code>, which calculates a
      lower bound on the time required to reach the destination
      from stop <code>s</code>.  A lower bound can be obtained by
      computing the distance between the two stops, and dividing it by
      the maximum speed of the tram which you can assume to be 260
      coordinate points per minute.
    <li> Also implement method <code>compare(State s1, State s2)</code>
      in class <code>StateComparator</code> so that it can be used to
      order the nodes in the priotity queue based on <code>cost
	+ h(node)</code> as described in Part 1. Here the nodes are
      states that are defined by the stop and the time since
      departure.
    <li> Implement the A* search in class <code>TravelPlanner</code>.
      The <code>PriorityQueue</code> data structure comes in handy. An
      instance of the <code>StateComparator</code> class should be given as
      an argument to the <code>PriorityQueue</code> constructor.
  </ol>
</p>

<p>
  As before, you should return the obtained route as a backward-linked
  list of states.</p>

<p>
  The <code>Stop</code> class in the Java package provides
  functionality for listing the neighboring stops and for getting the
  minimum time required to get there (including the waiting time).
</p>

<p>
  If you prefer to not use the Java package and TMC, that's totally
  fine.  You'll find the stop information in <code>network.json</code>
  and the route descriptions in <code>lines.json</code>, both of which
  are self-explanatory.
</p>


    </div>
  </div>
</div>


<!-- Exercise 2.1 -->

<div class="solution" data-target='collapse'>
  <div class="solution__header">
    <a data-toggle="collapse" class="solution__toggle">
      <i class="fa fa-magic solution__icon"></i>
      <h1 class="solution__heading">Example solution</h1>

      <i class="fa fa-caret-down solution__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="solution__body">
      
<p>
  Example solutions for <a href="https://materiaalit.github.io/intro-to-ai-18/files/astar-solution.zip">Java</a>, <a href="https://materiaalit.github.io/intro-to-ai-18/files/AStar_model_python.zip">Python</a>.
</p>


    </div>
  </div>
</div>


You can find the lecture slides for this part on the <a href="https://courses.helsinki.fi/en/data15001/124845454">course homepage</a>
under Materials.

<h1 class="material-heading">
    Games

</h1>

<p>
  This week, we will study a classic AI problem: games.
  The simplest scenario, which we will focus on for the sake of
  clarity, are two-player, perfect-information games such as
  tic-tac-toe and chess.
</p>

<p>
  Another topic that we'll be able to get started with, and continue
  on next week, is reasoning under uncertainty using probability.
</p>

<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Learning objectives of Part 2
  </div>

  <div class="hint__body">
    
<table class="table">
  <tr>
    <th>
      Theme
    </th>
    <th>
      Objectives (after the course, you ...)
    </th>
  </tr>
  <tr>
    <td>
      Games and search (continued from last week)
    </td>
    <td>
      <ul>
	<li>can formulate a simple game (such as tic-tac-toe) as a game tree
	<li>can explain and implement the minimax algorithm and depth-limited alpha-beta pruning
	<li>can design a reasonable heuristic evaluation function in a game (e.g., chess)
      </ul>
    </td>
  </tr>
  <tr>
    <td>
      Reasoning under uncertainty (to be continued next week)
    </td>
    <td>
      <ul>
	<li>can express uncertain knowledge in a simple situation using a probabilistic model
	<li>can apply the Bayes theorem to calculate posterior probabilities given evidence in a simple scenario
      </ul>
    </td>
  </tr>
</table>


  </div>
</div>

<h1 class="material-heading">
    Games

</h1>

<p>
  Maxine and Minnie are true game enthusiasts. They just love games.
  Especially two-person, perfect information games such as tic-tac-toe
  or chess.
</p>

<p>
  One day they were playing tic-tac-toe. Maxine, or Max as her
  friends call her, was playing with X. Minnie, or Min as her
  friends call her, had the Os. The situation was
<pre>
       O| |O
       -+-+-
       X| |
       -+-+-
       X|O|
</pre>
  Max was looking at the board and contemplating her next move, as it
  was her turn, when she suddenly buried her face in her hands in
  despair, looking quite like Garry Kasparov playing Deep Blue in
  1997.
</p>

<p>
  Yes, Min was close to getting three Os on the top row, but Max could
  easily put a stop to that plan. So why was Max so pessimistic?
</p>

<h2 class="material-heading">
    Game Trees

</h2>

<p>
  To analyse games and optimal strategies, we will introduce the
  concept of a <b>game tree</b>. The game tree is similar to a search
  tree, such as the one in the Sudoku example discussed at the
  lecture.  (Remember that you should also study the lecture slides in
  addition to this material. Some material may be discussed in one but
  not the other.) The different states of the game are represented by
  nodes in the game tree. The "children" of each node N are the
  possible states that can be achieved from the state corresponding to
  N. In board games, the state of the game is defined by the board
  position and whose turn it is.
</p>

<p>
  Consider, for example, the following game tree which begins
  not at the root but in the middle of the game (because otherwise,
  the tree would be way too big to display).
  <br>
  <img width=80% src="../img/diagrams/tictactoe-tree-905ef5b4.png">
  <br>
  The game continues at the board position shown in the root node,
  numbered as (1) at the top, with Min's turn to place O at any of the
  three vacant cells. Nodes (2)--(4) show the board positions
  resulting from each of the three choices respectively. In the next
  step, each node has two possible choices for Max to play X each,
  and so the tree branches again.
</p>

<p>
  The game ends when either player gets a row of three, or when there
  are no more vacant cells. When starting from the above starting
  position, the game always ends in a row of three.
</p>

<p>
  Now consider nodes (5)--(10) on the second layer from the bottom.
  In nodes (7) and (9), the game is over, and Max wins with three X's
  in a row. In the remaining nodes, (5), (6), (8), and (10), the game
  is also practically over, since Min only needs to place her O
  in the only remaining cell to win. We can thus decide that the
  end result, or the <b>value</b> of the game in each of the nodes
  on the second level from the bottom is determined. For the
  nodes that end in Max's victory, we'll say that the value
  equals +1, and for the nodes that end in Min's victory, we'll say
  that the value is -1.
</p>

<p>
  More interestingly, let's now consider the next level of nodes
  towards the root, nodes (2)--(4). Since we decided that both of the
  children of (2), i.e., nodes (5) and (6), lead to Min's victory, we
  can without hesitation attach the value -1 to node (2) as well.  For
  node (3), the left child (7) leads to Max's victory, +1, but the
  right child (8) leads to Min winning, -1. However, it is Max's turn
  to play, and she will of course choose the left child without
  hesitation. Thus, every time we reach the state in node (3), Max
  wins. Thus we can attach the value +1 to node (3).
</p>

<p>
  The same holds for node (4): again, since Max can choose where to
  put her X, she can always ensure victory, and we attach the value
  +1 to node (4).
</p>

<p>
  So far, we have decided that the value of node (2) is -1, which
  means that if we end up in such a board position, Min can ensure
  winning, and that the reverse holds for nodes (3) and (4): their
  value is +1, which means that Max can be sure to win if she only
  plays her own turn wisely.
</p>

<p>
  Finally, we can deduce that since Min is an experienced player, she
  can reach the same conclusion, and thus she only has one real
  option: give Max an impish grin and play the O in the middle of the
  board.
</p>

<p>
  In the diagram below, we have included the value of each node as
  well as the optimal game play starting at Min's turn in the root
  node.
  <br>
  <img width=80% src="../img/diagrams/tictactoe-values-71fdd825.png">
</p>

<p>
  The value of the root node, which is said to be the <b>value of the
  game</b>, tells us who wins (and how much, if the outcome is not
  just plain win or lose): Max wins if the value of the game is +1,
  Min if the value is -1, and if the value is 0, then the game will
  end in a draw. This all is based on the assumption that both players
  choose what is best for them.
</p>

<p>
  The optimal play can also be deduced from the values of the nodes:
  at any <b>Min node</b>, i.e., node where it is Min's turn, the
  optimal choices are given by those children whose value is minimal,
  and conversely, at any <b>Max node</b>, where it is Max's turn, the
  optimal choices are given the the children whose value is maximal.
</p>

<h2 class="material-heading">
    Minimax Algorithm

</h2>

<p>
  We can exploit the above concept of the value of the game to obtain
  an algorithm with optimal game play in, theoretically speaking, any
  deterministic, two-person, perfect-information game. Given a state
  of the game, the algorithm simply computes the values of the
  children of the given state and chooses the one that has the maximum
  value if it is Max's turn, and the one that has the minimum value if
  it is Min's turn.
</p>

<p>
  The algorithm can be implemented using the neat recursive
  functions below for Max and Min nodes respectively. This is
  known as the <b>Minimax algorithm</b> (see <a href="https://en.wikipedia.org/wiki/Minimax">Wikipedia: Minimax</a>).
</p>

<pre class="sh_java code-highlight"><code>    max_value(node):
1:     if end_state(node): return value(node)
2:     v = -Inf
3:     for each child in node.children():
4:        v = max(v, min_value(child))
5:     return v
</code></pre>

<pre class="sh_java code-highlight"><code>    min_value(node):
1:     if end_state(node): return value(node)
2:     v = +Inf
3:     for each child in node.children():
4:        v = min(v, max_value(child))
5:     return v
</code></pre>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Why so serious, Max? (1p)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
<p>
  Let's return to the tic-tac-toe game described in the beginning
  of this section. To narrow down the space of possible end-games
  to consider, we can observe that Max must clearly place an X on
  the top row to avoid imminent defeat:
  <pre>
       O|X|O
       -+-+-
       X| |
       -+-+-
       X|O|
  </pre>
  Now it's Min's turn to play an O. Evaluate the value of this state
  of the game as well as the other states in the game tree where the
  above position is the root, using the Minimax algorithm.
</p>


    </div>
  </div>
</div>


<!-- Exercise 2.2 -->

<div class="solution" data-target='collapse'>
  <div class="solution__header">
    <a data-toggle="collapse" class="solution__toggle">
      <i class="fa fa-magic solution__icon"></i>
      <h1 class="solution__heading">Example solution</h1>

      <i class="fa fa-caret-down solution__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="solution__body">
      
<p>
  Here's the game tree with the values of each node.
</p>

<img src="../img/exercises/ex2/tree_Ex2_2-90b2e222.png" width=80%>

<p>
  As you can see, Max has all the reason to be serious since by
  playing in the bottom-right corner (Node (4)), Min can guarantee a
  win (just follow the orange arrows). The inevitable victory of Min
  can also be seen from the value of the game at the root node which
  is &ndash;1.
</p>


    </div>
  </div>
</div>

<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Sounds good, can I go home now?
  </div>

  <div class="hint__body">
    
<p>
  As stated above, the Minimax algorithm can be used to implement
  optimal game play in any deterministic, two-player,
  perfect-information game. Such games include tic-tac-toe, connect
  four, chess, Go, etc. (Rock-paper-scissors is not in this class of
  games since it involves information hidden from the other player;
  nor are Monopoly or backgammon which are not deterministic.) So as
  far as this topic is concerned, is that all folks, can we go home
  now?
</p>

<p>
  The answer is that in theory, yes, but in practice, no. In many
  games, the game tree is simply way too big to traverse in full.  For
  example, in chess the average branching factor, i.e., the average
  number of children (available moves) per node is about 35.  That
  means that to explore all the possible scenarios up to only two
  moves ahead, we need to visit approximately 35 x 35 = 1225 nodes
  -- probably not your favorite pencil-and-paper homework exercise...  A
  look-ahead of three moves requires visiting 42875 nodes; four moves
  1500625; and ten moves 2758547353515625 (that's about
  2.7 quadrillion) nodes.
</p>

<p>
  In Go, the average branching factor is estimated to be about 250.
  Go means no-go for Minimax.
</p>


  </div>
</div>

<p>
  Next, we will learn a few more tricks that help us manage massive
  game trees, and that were crucial elements in IBM's Deep Blue
  computer defeating the chess world champion, Garry Kasparov, in
  1997.
</p>


<h2 class="material-heading">
    Depth-limited minimax and heuristic evalution criteria

</h2>

<p>
  If we can afford to explore only a small part of the game tree,
  we need a way to stop the minimax recursion before reaching an
  end-node, i.e., a node where the game is over and the winner
  is known. This is achieved by using a <b>heuristic
    evaluation function</b> that takes as input a board position,
  including the information about which player's turn is next,
  and returns a score that should be an estimate of the likely
  outcome of the game continuing from the given board position.
</p>

<p>
  Good heuristics for chess, for example, typically count the amount
  of material (pieces) weighted by their type: the queen is usually
  considered worth about two times as much as a rook, three times a
  knight or a bishop, and nine times as much as a pawn. The king is of
  course worth more than all other things combined since losing it
  amounts to losing the game. Further, occupying the strategically
  important positions, e.g., near the middle of the board, is
  considered an advantage.
</p>

<p>
  The minimax algorithm presented above requires minimal changes
  to obtain a <b>depth-limited</b> version where the heuristic
  is returned at all nodes at a given depth limit.
</p>

<h2 class="material-heading">
    Alpha-beta pruning

</h2>

<p>
  Another breakthrough in game AI, proposed independently by several
  researchers including John McCarthy in and around 1960,
  is <a href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning">alpha-beta
  pruning</a>. For small game trees, it can be used independently of
  the heuristic evaluation method, and for large trees, the two can be
  combined into a powerful method that has dominated the area of game
  AI for decades.
</p>

<p>
  A good example of the idea behind alpha-beta-pruning can be seen
  in the tic-tac-toe game tree that we discussed above -- scroll
  up and let the image of the root node burn into your retina.
</p>

<p>
  Now simulate the Minimax algorithm at the stage where the value of
  the left child node, -1, has been computed and returned to the
  <code>min_value</code> function. The next step would be to
  call <code>max_value</code> to compute the value of the middle
  child. But hold on! If the left child guarantees victory for Minnie,
  what does it matter how the game ends if she chooses to play any
  other way? As soon as the algorithm finds a child node with the best
  possible outcome for the player whose turn it is, it can make a
  choice and avoid computing the values of all the other child nodes.
</p>

<p>
  To implement this in a similar fashion as the Minimax algorithm
  requires small changes in the <code>min_value</code> and
  <code>max_value</code> functions. Understanding the connection
  between these changes and the principle illustrated by the above
  pruning example is not as easy as it may sound, so please pay
  close attention to this topic and work out the examples and
  exercises with care.
</p>

<pre class="sh_java code-highlight"><code>    max_value(node, alpha, beta):
1:     if end_state(node): return value(node)
2:     v = -Inf
3:     for each child in node.children():
4:        v = max(v, min_value(child, alpha, beta))
5:        alpha = max(alpha, v)
6:        if alpha >= beta: return v
7:     return v
</code></pre>

<pre class="sh_java code-highlight"><code>    min_value(node, alpha, beta):
1:     if end_state(node): return value(node)
2:     v = +Inf
3:     for each child in node.children():
4:        v = min(v, max_value(child, alpha, beta))
5:        beta = min(beta, v)
6:        if alpha >= beta: return v
7:     return v
</code></pre>

<p>
  An important thing to remember is that the <code>alpha</code> value
  is updated only at the Max nodes, and the <code>beta</code> value is
  updated only at the Min nodes. The updated values are passed as
  arguments down to the children, but not up to the calling parent
  node. (That is, the arguments are passed <i>as values</i>, not <i>as
  references</i> in programming lingo.)
</p>

<p>
  The interpretation <code>alpha</code> and <code>beta</code> is that
  they provide the interval of possible values of the game at the node
  that is being processed:
  <code>alpha</code> &le; value &le; <code>beta</code>. This interval
  is updated during the algorithm, and if at some point, the interval
  shrinks so that <code>alpha = beta</code>, we know the value and
  can return it to the parent node without processing any more
  child nodes. It can also happen that <code>alpha > beta</code>,
  which implies that the current node will never be visited in
  optimal game play, and its processing can likewise be aborted.
</p>

<p>
  When starting the recursion at the root node, we use the minimum and
  maximum value of the game as the <code>alpha</code>
  and <code>beta</code> values respectively. For tic-tac-toe and
  chess, for instance, where the outcome is plain win/loss, this
  is <code>alpha = -1</code> and <code>beta = 1</code>. If the range
  of possible values is not specified in advance, we initialize
  as <code>alpha = -&infin;</code> and <code>beta = &infin;</code>.
</p>

<p>
  It is useful to work out a few examples to really understand the
  beauty of alpha-beta pruning. Here's another tic-tac-toe
  example.
  <br>
  <img width=80% src="../img/diagrams/tictactoe-alphabeta-e8cb918f.png">
  <br>
</p>

<p>
  You should simulate the algorithm to see that the two branches
  that are grayed out  indeed get pruned -- therefore, it is
  actually a bit misleading to even show their minimax values
  since the algorithm never computes them.
</p>

<p>
  Remember that the Max nodes (such as the root node) only update
  the <code>alpha</code> value and pass it down to the next
  child node. Check that you reach a situation where
  <code>alpha=0</code> and  <code>beta=-1</code> in a
  Min node. Actually you should reach such a situation twice.
</p>

<p>
  Another good example (except for the choice of colors) can be found
  from Bruce Rosen's lecture notes for <i>Fundamentals of Artificial
  Intelligence - CS161</i> at
  UCLA: <a href="http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html">here</a>.
  Note in particular how he emphasizes the fact that the tree is only
  expanded node by node as the algorithm runs, instead of running the
  algorithm on a full tree as is often suggested by diagrams such as
  the ones we use in this material (shame on us!).  Rosen's example
  also illustrates a scenario where the value of the game is not
  constrained to be –1,0, or +1, and the algorithm starts at the root
  with <code>alpha = –&infin;</code> and
  <code>beta = &infin;</code>.
</p>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Alpha-beta for tic-tac-toe (1p)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
<p>
  Maxine wants to try again -- best out of three! Minnie agrees and
  after a while, they arrive at the following position
  <pre>
       O|X|O
       -+-+-
       X| |X
       -+-+-
        |O|
  </pre>
  It's again Min's turn to play an O. Evaluate the value of this state
  of the game as well as the other states in the game tree where the
  above position is the root, using alpha-beta pruning. Start the
  recursion by calling <code>min-value(root, -1, 1)</code> where
  <code>root</code> is the above board position.
</p>

<p>
  What is the value of the game, and what are the optimal moves?
</p>


    </div>
  </div>
</div>


<!-- Exercise 2.3 -->

<div class="solution" data-target='collapse'>
  <div class="solution__header">
    <a data-toggle="collapse" class="solution__toggle">
      <i class="fa fa-magic solution__icon"></i>
      <h1 class="solution__heading">Example solution</h1>

      <i class="fa fa-caret-down solution__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="solution__body">
      
<p>
  As was stated in the exercise, the recursion
  is started by calling
  <code>min-value</code> for the root node (Node (1) below) with
  arguments
  <code>alpha=-1, beta=1</code>. These values are then passed to the
  child nodes, starting with the leftmost child (Node (2)), and from
  it further down all the way to the leaf node (5). The return value,
  which is passed up the parent node (3), is &ndash;1 since in this
  case, Min wins with three Os in a row.  Strictly speaking, this
  already causes pruning to occur in Node (3): it is a Min node, and
  thus it updates its beta value, and the beta value becomes
  &ndash;1. The test <code>alpha =-1 &le; beta=-1</code> (line 7
  in the pseudocode) triggers the return condition. However, the
  effect is null since there wouldn't have been any other children of
  Node (3) anyway.
</p>

<img src="../img/exercises/ex2/alphabeta_Ex2_3-3ed29945.png" width=60%>

<p>
  Next, Node (3) returns the value &ndash;1 to its parent, Node (2).
  As a Max node, Node (2) would update its alpha value but since the
  value returned by the child is &ndash;1 which is already the same
  as the current alpha value, no update occurs (line 6 in the
  pseudocode). The processing of nodes (4) and (6) is analogous to
  that of nodes (3) and (5) respectively.
</p>

<p>
  Interesting things start to happen in the root node when the value
  &ndash;1 is returned from Node (2). The root node is a Min node and
  it updates its beta value to be <code>beta=-1</code> (line 6 in the
  pseudocode), and therefore, the test <code>alpha=-1 &le;
  beta=-1</code> again triggers pruning and the other branches of the
  tree need not be traversed at all!
</p>

<p>
  The optimal game play can now be obtained by always choosing the
  child node with the minimum (maximum) value in Min (Max)
  nodes <i>among the child nodes that were visited</i>. The result is
  guaranteed to be the same as that of the Minimax algorithm, i.e.,
  optimal play for both players. For Max this is bad news: it's Min's
  victory even best-out-of-three...
</p>


    </div>
  </div>
</div>

<p>
  Notice that while the left-to-right order of the children of each
  node, i.e., the order in which the children are processed in the
  loop on lines 4--7, is arbitrary, it can have significant impact
  on which branches are pruned.
</p>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Alpha-beta programming exercise (1p)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
<p>
  Now we feel confident enough about concepts and ideas behind the
  Minimax algorithm and alpha-beta pruning that we can start
  programming. We'll implement a tic-tac-toe bot.
</p>

<p>
  <ol>
    <li> First implement the basic framework for the game: a
      data structure (class) for board positions, the functions for
      checking whether either player has a row of three, and a
      function for producing the list of children for a given board
      position.
    <li> Then implement the Minimax algorithm according to the pseudo-code
      given above. The algorithm should return for any given board
      position, the value of the game: -1, 0, or 1.
    <li> Using the previous step, modify the program so that it also
      outputs the optimal move for the player whose turn it is (which
      is given as an input, of course). You can do this by keeping
      record of the child node that yields the highest (lowest) value
      in a Max (Min) node.
    <li> You can test the solution at this stage by using it to solve
      the above pencil-and-paper exercises.
    <li> As the culmination of this exercise, modify the algorithm to
      implement alpha-beta pruning as detailed in the pseudo-code
      above. To see whether you gain any speed-up, you can see how
      long the algorithm runs (or how many recursive function calls
      are performed) with or without alpha-beta pruning -- simply
      comment out line 7 with the test <code>alpha >= beta</code> to
      revert back to vanilla Minimax.
  </ol>

  As a bonus question, you can think about how to order the child
  nodes so that as much pruning is done as possible.


    </div>
  </div>
</div>


<!-- Exercise 2.4 -->

<div class="solution" data-target='collapse'>
  <div class="solution__header">
    <a data-toggle="collapse" class="solution__toggle">
      <i class="fa fa-magic solution__icon"></i>
      <h1 class="solution__heading">Example solution</h1>

      <i class="fa fa-caret-down solution__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="solution__body">
      
<p>
  Example solutions for <a href="https://materiaalit.github.io/intro-to-ai-18/files/AlphaBeta_model_solution.zip">Java</a>, <a href="https://materiaalit.github.io/intro-to-ai-18/files/AlphaBeta_model_python.zip">Python</a>.
</p>


    </div>
  </div>
</div>

<h1 class="material-heading">
    Reasoning under Uncertainty

</h1>

<p>
  In this section, we'll study methods that can cope with
  uncertainty. The history of AI has seen various competing approaches
  to handling uncertain and imprecise information: fuzzy logic,
  non-monotonic logic, the theory of plausible reasoning <i> et
  cetera</i>. In most cases, probability theory has turned out to be
  the most principled and consistent paradigm for reasoning under
  uncertainty.
</p>

<p>
  If you want an objective and diplomatic view on the matter, don't
  ask me. I'll just repeat a counter-argument made by a proponent of
  fuzzy logic when he tried to get around a rigorous formal proof
  showing that any method of inference where degrees of plausibility
  are represented as real numbers, other than probability theory, is
  inconsistent: the <a href="http://sipi.usc.edu/~kosko/Fuzziness_Vs_Probability.pdf">response of the fuzzy logic proponent</a> was that
  since the proof is based on <i>ordinary (two-valued) logic, it
    doesn't apply to fuzzy logic.</i> Now that is a counter-argument
  that is hard to refute!
</p>

<h2 class="material-heading">
    Probability Fundamentals

</h2>

<p>
  We are working to add material about the basic concepts of
  probability theory: probabilistic model, events, joint
  probability, conditional probability, etc.
</p>

<p>
  Since this section is not finished yet, feel free to refresh these
  concepts from your favorite source.  Two great examples are:
  <ul>
    <li>Ian Goodfellow, Yoshua Bengio & Aaron Courville: <a href="http://www.deeplearningbook.org/">Deep Learning</a> (Section 3)
    <li>Charles Grinstead & J. Laurie Snell: <a href="http://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/amsbook.mac.pdf">Introduction to Probability</a> (pdf file, 3.2MB, 520 pages)
  </ul>
  The Bayes rule (aka Bayes theorem) is the single most important tool
  from probability calculus, and we'll be using in again and again for
  building AI applications, here is some more material about it
  in particular:
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Bayes%27_theorem#Drug_testing">Wikipedia: Bayes theorem (Section <i>Drug testing</i>)</a>
    <li><a href="http://www.youtube.com/watch?v=tRE6mKAIkno">Youtube: Maths Doctor, A Level Statistics 1.5 Bayes' Theorem and medical testing</a>
    <li>Better Explained: <a href="http://betterexplained.com/articles/understanding-bayes-theorem-with-ratios/">Understanding Bayes Theorem with Ratios</a>
  </ul>
</p>



<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Rolling the Dice (1p)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
<p>
  The lecturer has two dice in his office (true story). One of them is
  an ordinary die and will yield any result from one to six with equal
  probability.  However, the other die is loaded (true story, again).
  It will yield a six with probability 1/2 and any other outcome with
  probability 1/10. He will roll the ordinary die first, and then
  the loaded one. Calculate the following probabilities. Recall
  that <i>P(A|B)</i> means the conditional probability of <i>A</i>
  given <i>B</i>.
</p>

<p>
  <ol>
    <li> P("both outcomes are 6")
    <li> P("neither outcome is 6")
    <li> P("the sum of the outcomes equals 9")
    <li> P("the sum of the outcomes equals 9" | "at least one outcome is 6")
    <li> P("at least one outcome is 6" | "the sum of the outcomes equals 9")
  </ol>
</p>

<p>
  <i>Hint:</i> We know that probability calculus can be confusing, but
  keep calm and carry on, you'll get the hang of it!
</p>


    </div>
  </div>
</div>


<!-- Exercise 2.5 -->

<div class="solution" data-target='collapse'>
  <div class="solution__header">
    <a data-toggle="collapse" class="solution__toggle">
      <i class="fa fa-magic solution__icon"></i>
      <h1 class="solution__heading">Example solution</h1>

      <i class="fa fa-caret-down solution__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="solution__body">
      
<p>
  <ol>
    <li> Because the outcomes are independent, we can use the product rule to
      obtain<br><br>
      P("both outcomes are 6") = P("first outcome is 6") &times; P("second outcome is 6")<br>
	&nbsp;&nbsp;&nbsp;= 1/6 &times; 1/2 = 1/12 &asymp; 0.083<br><br>
    <li>
      P("neither outcome is 6") = P("first is not 6") &times; P("second is not 6") = 5/6 &times; 1/2 = 5/12 &asymp; 0.417<br><br>
    <li>
      Let's denote the result of the two dice with the pair (m,n), where m is the
      outcome of the first (fair) die, and n is the outcome of the second (loaded) die.
      Together the outcomes define the elementary event. The sum equals nine in the
      following elementary events: (3,6), (4,5), (5,4), (6,3). Note that the results
      (3,6) and (6,3) are distinct elementary events.<br><br>

      The result is obtained by summing up the probabilities of the aforementioned
      elementary events:<br><br>
      P((3,6)) + P((4,5)) + P((5,4)) + P((6,3)) =
	1/6 &times; 1/2 + 1/6 &times; 1/10 + 1/6 &times; 1/10 + 1/6 &times; 1/10
	= 8/60 &asymp; 0.133.<br><br>
    <li>
      Denote by A the event "the sum of the outcomes equals 9", and by B the event
      "at least one outcome is 6". Since the conditional probability is given by
      P(A | B) = P(A, B) / P(B), we start by calculating P(A, B) and
      P(B).<br><br>

      The elementary events where both A and B occur are
      (3,6) and (6,3). Thus, P(A,B) = 1/6 &times; 1/2 + 1/6 &times; 1/10 =
	6/60. Event B, on the other hand, is the complement of event
      "neither outcome is 6" from item (b) above, so we can get its probability
      easiest by applying the rule P(B) = 1 &ndash; P(&not;B), to get
      P(B) = 1 &ndash; 5/12 = 7/12.<br><br>

      Thus we get the conditional probability by substituting into the formula
      P(A | B) = P(A, B) / P(B) = 6/60 / (7/12) = 6/35 &asymp; 0.171.<br><br>
    <li>
      With the notation of the previous item, we get
      P(B | A) = P(A, B) / P(A) = 6/60 / (8/60) = 6/8 &asymp; 0.75, where
      P(A) = 8/60 was calculated in item (c) above.
  </ol>
</p>


    </div>
  </div>
</div>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil exercise__icon"></i>
      <h1 class="exercise__heading">Bayes rule (1p)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
<p>
  Let's use the same dice as in the previous exercise.
</p>

<p>
  <ol>
    <li> What is the distribution of the sum of the outcomes when
      rolling the ordinary die twice?
    <li> What is the distribution of the sum of the outcomes when
      rolling the loaded die twice?
    <li> Assume that either die (ordinary or loaded) is selected
      at random with probability 1/2 each. The selected die is
      rolled twice. Calculate the probability<br><br>
      <i>P("the die is loaded" | "the sum of the outcomes is 10")</i><br><br>
      Calculate the probability that the die is ordinary as well to
      make sure that the sum of the two probabilities equals one.
    <li> Again, either die is selected with equal probability.
      We notice that every time the die is rolled, the outcome is six.
      After how many rolls can we be at least 99% sure that the
      die is loaded? <br><br> <i>Hint:</i> Calculate the ratio of the
      posterior probabilities of each die after <i>k</i>
      rolls. If the posterior probability of the loaded die is over
      99%, then the ratio of the posterior probabilities is over
      0.99/0.01 = 99.
  </ol>
</p>

<p>
  If you have trouble with these exercises, you may wish to study
  additional material on the Bayes rule. Good pointers are provided above.
</p>


    </div>
  </div>
</div>


<!-- Exercise 2.6 -->

<div class="solution" data-target='collapse'>
  <div class="solution__header">
    <a data-toggle="collapse" class="solution__toggle">
      <i class="fa fa-magic solution__icon"></i>
      <h1 class="solution__heading">Example solution</h1>

      <i class="fa fa-caret-down solution__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="solution__body">
      
<p>
  <ol>
    <li>
      The "distribution of the outcomes" means a list of probabilities for
      each possible outcome (here: sums of the two dice). The sum can take
      any value between 2, ..., 12. With a fair die, each elementary event
      (m,n) has probability 1/6 &times; 1/6 = 1/36, so the distribution is
      obtained by counting how many elementary events correspond to each
      possible sum and multiplying this by 1/36.<br><br>

      [P("sum is 2"), ..., P("sum is 12")] = [1/36, 2/36, 3/36, 4/36, 5/36,
      6/36, 5/36, 4/36, 3/36, 2/46, 1/36]<br><br>

    <li>
      With the loaded die, the elementary events have different
      probabilities, so a simple counting and multiplication won't do.
      Every event (m,n) where m&lt;6 and n&lt;6 has probability 1/10 &times;
      1/10 = 1/100. Every event (m,n) where m&lt;6 and n=6, or m=6 and n&lt;6,
      has probability 1/10 &times; 1/2 = 1/20. And finally, the event
      (6,6) has probability 1/2 &times 1/2 = 1/4.<br><br>

      We now get, for example, the probability that the sum is 9 from
      <br><br>

      P((3,6)) + P((4,5)) + P((5,4)) + P((6,3)) = 1/20 + 1/100 + 1/100 + 1/20
      = 12/100 = 0.12<br><br>

      The complete distribution is given by<br><br>

      [P("sum is 2"), ..., P("sum is 12")]<br>
      = [1/100, 2/100, 3/100, 4/100, 5/100, 14/100, 13/100, 12/100, 11/100, 10/100, 25/100]<br><br>

      To make sure we haven't messed up (who, me?), we can sum up the
      probabilities to check that the total is 1.0; i.e.,
      1+2+3+4+5+14+13+12+11+10+25=100. Yes!
<br><br>

    <li>
      Here we can apply the Bayes formula:<br><br>
      <pre>
      P("loaded die" | "the sum is 10")
         P("the sum is 10" | "loaded die") &times P("loaded die")
       = ---------------------------------------------------
                          P("the sum is 10")</pre>

      The first term in the numerator was calculated in the previous item, and
      the other term is known to be 1/2 by assumption. However, we'll have to
      calculate the annoying denominator by splitting it into two alternative
      ways to get the sum 10.<br><br>

      P("sum is 10" | "fair die") &times; P("fair die") + P("sum is 10" | "loaded die")
      &times; P("loaded die") <br>
      = 3/36 &times; 1/2 + 11/100 &times 1/2 = 29/300 &asymp; 0.0966.<br><br>

      In case you have difficulty following these calculations, please
      take a look at the additional material on Bayes rule above.
      Note that the numerical values of both of the conditional
      probabilities in the above expression come from the two
      distributions we calculated in items 1 & 2.<br><br>

      Substituting these values into the Bayes rule we get
      <br><br>
      P("loaded die" | "sum is 10") = 11/100 &times 1/2 / (29/300) = 33/58 &asymp; 0.5689.
      <br><br>

      When calculating the conditional probability P("fair die" | "sum
      is 10") by the Bayes rule, we'll end up with the very same
      denominator, whose value we already calculated to be 29/300,
      and thus we get:
      <br><br>
      P("fair die" | "sum is 10") = 3/36 &times; 1/2 / (29/300) =
      25/58.<br><br>

      The sum of the probabilities of the loaded and the fair die is
      33/58 + 25/58 = 1  as it should!<br><br>

      <i>Note:</i> The end result of the above calculation is that
      observing that the sum is 10 has almost no effect on our belief about
      which die was chosen: before the observation, our prior probability
      for the loaded die was 0.5, and after the observation, our posterior
      probability is 0.5689. You can think about what outcome would have
      changed our belief the most.<br><br>

    <li>
      Following the hint, it'll be enough to check whether<br><br>
      <pre>
	  P("loaded die" | "k times 6")
          ----------------------------- > 99
           P("fair die" | "k times 6")
      </pre>
      The posterior probability ratio can be obtained by applying the
      Bayes rule to both of the conditional probabilities above:<br><br>
      <pre>
	  P("k times 6" | "loaded die") &times P("loaded die")
          -----------------------------------------------
                          P("k times 6")
        --------------------------------------------------
	    P("k times 6" | "fair die") &times P("fair die")
            -------------------------------------------
                          P("k times 6") </pre>
      where the annoying denominator cancels. Since the prior probabilities
      are the same (0.5), they too cancel (which doesn't happen in general).
      What is left is the ratio of the likelihood terms:<br><br>
      P("k times 6" | "loaded die") / P("k times 6" | "fair die")
      = (1/2)<sup>k</sup> / (1/6)<sup>k</sup> = 3<sup>k</sup>.<br><br>
      The smallest k for which 3<sup>k</sup> &gt; 99 is k=5. Thus, five
      rolls are required until the posterior probability of the loaded die
      is greater than 99%.
  </ol>
</p>


    </div>
  </div>
</div>

        </div>
      </div>

      <div class="footer-wrapper">
        <footer class="footer">
  <div>
    This material is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons BY-NC-SA 4.0 License</a>.

  </div>
  <div class="improvement">
    <a href="https://github.com/materiaalit/intro-to-ai-18/issues/new"  target="_blank" rel="noopener">
  <button class='btn btn-primary'>
    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i> Report an error
  </button>
</a>
<a href="https://github.com/materiaalit/intro-to-ai-18/edit/master/source/part2.html.erb" target="_blank" rel="noopener">
  <button class='btn btn-primary'>
    <i class="fa fa-pencil" aria-hidden="true"></i>
 Edit this page
  </button>
</a>
     <a href="https://github.com/materiaalit/intro-to-ai-18" class="footer__github-link" target="_blank" rel="noopener">
      <i class="fa fa-github"></i>
    </a>
  </div>
</footer>

      </div>
    </div>

    <div class="modal fade" id="tmc-login-modal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <form id="tmc-login-form">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title">Log in with your Test My Code Account</h4>
        </div>
        <div class="modal-body">
          <div class="alert alert-info">
            Don't have an account yet? <a href="https://tmc.mooc.fi/user/new" class="alert-link" target="_blank" rel="noopener">Create one!</a>
          </div>

          <div class="alert alert-danger" id="tmc-login-error" style="display: none;"></div>

          <div class="form-group">
            <label>Username</label>
            <input type="text" id="tmc-login-username" class="form-control" placeholder="Username"/>
          </div>

          <div class="form-group">
            <label>Password</label>
            <input type="password" id="tmc-login-password" class="form-control" placeholder="Password"/>
          </div>

          <div class="form-group">
            <label>Course</label>

            <div class="form-check">
              <label class="form-check-label">
                <input type="radio" class="form-check-input" name="tmcLoginCourse" value="intro-to-ai-18" checked>
                 Introduction to Artificial Intelligence 2017 (intro-to-ai-18)
              </label>
            </div>

            <small class="form-text text-muted">
              Course selection may affect the contents of the material.
            </small>
          </div>
        </div>
        <div class="modal-footer">
          <a class="btn btn-secondary" data-dismiss="modal">Close</a>
          <button type="submit" class="btn btn-primary">Log in</button>
        </div>
      </form>
    </div>
  </div>
</div>


    <div class="table-of-contents-layer" id="table-of-contents-layer">
</div>

<div class="table-of-contents" id="table-of-contents">
  <h1 class="table-of-contents__heading">
    Table of Contents
  </h1>

  <div class="table-of-contents__content">
    <ul id="table-of-contents-list"></ul>
  </div>
</div>


    <script>
  window._QUIZNATOR_ENABLED = true;
</script>

<script src="https://quiznator.mooc.fi/javascripts/plugin-loader.min.js"></script>


    <script src="https://code.jquery.com/jquery-3.1.1.min.js"
	    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
	    crossorigin="anonymous"></script>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script>
      window.SD_SHOW_SURVEY = ['part6', 'part7'].indexOf(window.location.pathname.replace(/\//g,'')) >= 0;
    </script>

    <script src="../javascripts/scripts-f5e4b5a8.js"></script>

    <script src="https://use.fontawesome.com/ed2f73836b.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.js"></script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js'></script>

    <script>window.cookieconsent.initialise({"palette":{"popup":{"background":"#000"},"button":{"background":"#f1d600"}}});</script>
  </body>
</html>
